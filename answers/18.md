>方法一 递归

由于二叉树的性质,很容易想到递归的思路,此时考虑何时截至,向上递归,以及每次递归时进行什么操作即可

```
class Solution {
public:
    TreeNode* flipTree(TreeNode* root) {
        if(!root) return nullptr;   //当访问到空指针,说明越界访问,已越过叶节点,故截止.开始递归
        TreeNode* tmp = root->left; //交换左右节点
        root->left = root->right;
        root->right = root->left;
        return root;
    }
};
```

>方法二 辅助栈

由二叉树的遍历时常用栈,队列,故而联想

又由于需要镜像,故选择先入先出的栈
```
class Solution {
public:
    TreeNode* flipTree(TreeNode* root) {
        if(!root) return nullptr;
        stack<TreeNode *> stk;
        stk.push(root);
        while(!stk.empty()){
            TreeNode* node = stk.top(); //存储当前根节点
            stk.pop();
            if(node->left) stk.push(node->left);    //存储该根节点左右节点
            if(node->right) stk.push(node->right);
            TreeNode* tmp = node->left; //交换
            node->left = node->right;
            node->right = tmp;
        }
        return root;
    }
};
```