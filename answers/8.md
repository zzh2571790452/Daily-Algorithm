由于 Alice 先手，那么 Alice 选择删除 [1,n−1]，可以剩下 nums[0]；选择删除 [0,n−2]，可以剩下 nums[n−1]。由于只剩下一个数，游戏结束。

Alice 可以取这两种情况的最大值。

所以答案 ≥max(nums[0],nums[n−1])。

下面证明，大于号是取不到的。

反证法，假设答案严格大于 max(nums[0],nums[n−1])。

设最终剩下的数为 x=nums[i]。由于 x>max(nums[0],nums[n−1])，所以 x 不在 nums 的两端，即 1≤i≤n−2。

讨论前两轮的操作：

+ 第一轮，Alice 操作。Alice 不能移除 x，只能移除其他不含 x 的子数组。这个子数组要么位于 x 的左侧，要么位于 x 的右侧。由于 1≤i≤n−2，所以移除子数组后，一定剩下至少两个数（游戏没有结束），且至少剩下 nums[0] 和 nums[n−1] 中的一个数。
+ 第二轮，Bob 操作。如果剩下的数包含 nums[0]，那么 Bob 可以删除其他数，最终剩下 nums[0]。如果剩下的数包含 nums[n−1]，那么 Bob 可以删除其他数，最终剩下 nums[n−1]。矛盾，所以答案不可能严格大于 max(nums[0],nums[n−1])。
综上所述，Alice 的最佳策略是第一回合就结束游戏，答案为

max(nums[0],nums[n−1])
```
class Solution {
public:
    int finalElement(vector<int>& nums) {
        return max(nums[0],nums[nums.size()-1]);
    }
};
```