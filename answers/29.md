```
int partition(vector<int>& nums,int l,int r){
	int i=l,j=r;
	while(i<j){
		while(i<j&&nums[j]>nums[l]) j--;
		while(i<j&&nums[i]<nums[l]) i++;
		swap(nums[i],nums[j]);
	}
	swap(nums[l],nums[i]);
	return i;
}

void quicksort(vector<int>& nums,int l,int r){
	if(l>=r) return;
	int i = partition(nums,l,r);
	quicksort(nums,l,i-1);
	quicksort(nums,i+1,r);
}
```

尾递归优化:
```
void quicksort(vector<int>& nums,int l,int r){
	while(l<r){		//递归处理短数组,循环处理长数组
		int i = partition(nums,l,r);
		if(i-1<r-i){
			quicksort(nums,l,i-1);
			l=i+1;
		}else{
			quicksort(nums,i+1,r);
			r=i-1;
		}
	}	
}
```

随机基准数:
```
int partition(vector<int>& nums, int l, int r) {
    // 在闭区间 [l, r] 随机选取任意索引，并与 nums[l] 交换
    int ra = l + rand() % (r - l + 1);
    swap(nums[l], nums[ra]);
    // 以 nums[l] 作为基准数
    int i = l, j = r;
    while (i < j) {
        while (i < j && nums[j] >= nums[l]) j--;
        while (i < j && nums[i] <= nums[l]) i++;
        swap(nums[i], nums[j]);
    }
    swap(nums[i], nums[l]);
    return i;
}
```