>方法一 后序遍历+剪枝

思路是对二叉树做后序遍历，从底至顶返回子树深度，若判定某子树不是平衡树则 “剪枝” ，直接向上返回。
```
class Solution {
public:
    bool isBalanced(TreeNode* root) {
        return recur(root) != -1;
    }
private:
    int recur(TreeNode* root) {
        if (root == nullptr) return 0;
        int left = recur(root->left);
        if(left == -1) return -1;   //剪枝
        int right = recur(root->right);
        if(right == -1) return -1;  //剪枝
        return abs(left - right) < 2 ? max(left, right) + 1 : -1;
    }
};
```

>方法二 先序遍历

直接比较每个节点左右子树的深度
```
class Solution {
public:
    bool isBalanced(TreeNode* root) {
        if (root == nullptr) return true;
        return abs(depth(root->left) - depth(root->right)) <= 1 && isBalanced(root->left) && isBalanced(root->right);   //遍历每个节点的子树平衡性
    }
private:
    int depth(TreeNode* root) {
        if (root == nullptr) return 0;
        return max(depth(root->left), depth(root->right)) + 1;  //计算深度
    }
};
```